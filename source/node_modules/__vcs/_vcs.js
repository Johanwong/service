module.exports = function () { console.log('== V C S ==') }

/*
// @TODO: make it compatible with "virtual dom"
console.log('==========')
//////////////////////////////////
var obj1 = {
  num: 2
}
function addToThis (a, b, c) {
  return this.num + a + b + c
}
var fn = addToThis.bind(obj1)
console.log(fn('x','y', 'z'))
//////////////////////////////////
function test (x) {
  return [
    this.a,
    this.b,
    this.c,
    x
  ].join(' ')
}

test.a = 'A'
test.b = 'B'
test.c = 'C'
test   = test.bind(test)

console.log(test('D'))


*/
////////////////////////////////////////////////////////////////////////
// REQUIRE BIN - (1/2)
/********************************************************************
  COMPONENT - ./MyThunk.js
********************************************************************/
// module.exports = MyThunk
function Hook (db, component, tracks, TEMP) {
  this.db = db
  this.component = component
  this.tracks = tracks
  this.TEMP = TEMP
  this.untrack = []
}
Hook.prototype.unhook = function() {
  logger(null, ':::: unhook() -> untrack()')
  this.untrack.forEach(function (untrack) {
    untrack()
  })
}
Hook.prototype.hook = function (node) {
  var THIS = this
  var DATA = THIS.TEMP
  var initialize = true
  logger(null, ':::: hook() -> track()')
  var t = THIS.db.trackable()
  THIS.tracks.forEach(function (keyrange) {
    THIS.untrack.push(t.track(keyrange))
  })
  t.on('data', function ondata (data) {
    // @TODO: debug slowness while open devtools
    // https://github.com/serapath/level-tracker/blob/master/index.js
    var key = data.key
    var val = data.value
    if (DATA[key] !== val) {
      logger(null, ':::: .on("data") -> update()')
      logger(null, '<b>OLD:</b> ' + JSON.stringify(data))
      logger(null, '<b>PATCH WITH:</b> {'+key+': "'+val+'" }')
      DATA[key] = val
      logger(null, '<b>NEW:</b> ' + JSON.stringify(data))
      var oldTree = THIS.vtree
      var newTree = THIS.component(DATA)
      var patches = diff(oldTree, newTree)
      patch(node, patches)
    } else if (initialize) {
      logger(null, ':::: initialize()')
      logger(null, '<b>DATA:</b> ' + JSON.stringify(DATA))
      var oldTree = THIS.vtree
      var newTree = THIS.component(DATA)
      var patches = diff(oldTree, newTree)
      patch(node, patches)
      initialize = false
    }
  })
}
function MyThunk (params) {
  if (!(this instanceof MyThunk)) { return new MyThunk(params) }
  var db     = params.db
  var render = params.render
  var tracks = params.tracks
  if (!db||!render||!tracks) { throw new Error('missing params') }
  var TEMP = {}
  var hook = new Hook(db, init, Object.keys(tracks).map(
    function (key) {
      db.get(key, function (error, data) {
        if (error) {
          db.put(key, tracks[key], function handle (error) {
            if (error) { throw error }
          })
          TEMP[key] = tracks[key]
        } else {
          TEMP[key] = data
        }
      })
      return {gte:key,lte:key,suffix:'',terminator:'!',old:true}
    }
  ), TEMP)
  function init (DATA) { return h('div',{'ev-hook':hook},render(DATA)) }
  this.init = init
  this.hook = hook
}
MyThunk.prototype.type   = 'Thunk'
MyThunk.prototype.render = function render (Pre) {
  // Pre:  VNode | Thunk | Widget | VText
  // (= the Thunk is being diffed against)
  // When "Pre.render" was called by "diff",
  // it will do caching through:
  //   => Pre.vnode = Pre.render(previousPre)
  var useCache = Pre && Pre.vnode
  if (useCache) { logger(null, ':::: render cached thunk') } // @TODO: remove
  return useCache ? Pre.vnode : this.hook.vtree = this.init({})
}


/********************************************************************
  MAIN
********************************************************************/
function apilogger (opts) { console.log('API LOGGING: ', opts) }

var diff          = require('virtual-dom').diff
var patch         = require('virtual-dom').patch
var createElement = require('virtual-dom').create
var h             = require('virtual-dom').h
var process       = require('process')
var stream        = require('stream-browserify')
var level         = require('memdb')
// var tracker       = require('level-tracker')
var db            = tracker(level("data.db"), apilogger)
var myComponent   = MyThunk // require('./MyThunk.js')

var TEMP = { name: '', subname:'', info:'' }

document.querySelector('#content').appendChild(createElement(
  h('div', [
    h('h1', "CONTROLS - Change Component Data"),
    h('input', {className:'name',onchange:store}),
    h('button', {className:'name',onclick:update}, 'name'),
    h('br'),
    h('input', {className:'subname',onchange:store}),
    h('button', {className:'subname',onclick:update}, 'subname'),
    h('br'),
    h('input', {className:'info',onchange:store}),
    h('button', {className:'info',onclick:update}, 'info'),
    h('br'),
    h('hr'),
    h('h2', "COMPONENT - See rendered demo component"),
    h('div', { style: {border: '3px solid red', padding: '20px' }}, [
      myComponent({
        db: db,
        tracks: {
          name: 'John Doe',
          subname: 'alleycat',
          info: 'The random dude'
        },
        render:  function render (DATA) {
          return h('div', [
            h('h1', 'Name: ' + DATA['name']),
            h('h2', 'Subname: ' + DATA['subname']),
            h('h3', 'Info: ' + DATA['info'])
          ])
        }
      })
    ]),
    h('hr'),
    h('h2', "LOGGING - logging data changes + dump database"),
    h('button', {onclick:dump}, 'dump memdb 2 console'),
    h('button', {onclick:clear}, 'clear console')
  ])
))
function update (ev) {
  var key = ev.target.className
  db.put(key, TEMP[key], function handle (error) {
    if (error) { throw error }
  })
}
function store (ev) {
  var e = ev.target
  TEMP[e.className] = e.value
}


/********************************************************************
  LOGGING
********************************************************************/
var konsole
function logger (err, data) {
  if (!konsole) { konsole = getKonsole() }
  var x = document.createElement('div')
  x.className = 'line'
  x.style.fontFamily = 'Arial'
  x.style.paddingTop = '10px'
  x.innerHTML = data
  konsole.appendChild(x)
}
function dump () {
  logger(null, ':::: Dumping memdb content')
  db.get('name', logger)
  db.get('subname', logger)
  db.get('info', logger)
}
function clear () {
  var lines = [].slice.call(document.querySelectorAll('.line'))
  lines.forEach(function (line) {
    line.parentNode.removeChild(line)
  })
}
function getKonsole () {
  var style = document.createElement('style')
  style.innerHTML = [
    ".konsole{",
      "background-color: black;",
      "padding: 5px;",
      "box-sizing: border-box;",
      "color: white;",
      "position: absolute;",
      "width:100%;",
      "height:30vh;",
      "display: flex;",
      "overflow: scroll;",
      "flex-direction:column;",
    "}"
  ].join('')
  document.body.appendChild(style)
  var konsole = document.createElement('div')
  konsole.className = 'konsole'
  document.body.appendChild(konsole)
  return konsole
}
////////////////////////////////////////////////////////////////////////
// REQUIRE BIN - (2/2)
var readable = require('readable-stream').Readable
var writable = require('readable-stream').Writable
var defined  = require('defined')
var TRACKERSTREAMS = []
/********************************************************************
  SETUP
********************************************************************/
var memdb  = require('memdb')()
var db     = tracker(memdb, function (x) {
  x = JSON.stringify(x, null, 4)
  logging(null, 'API LOGGING:' + x)
})
/********************************************************************
  PREFILL DATABASE
********************************************************************/
db.put('test/a', 0)
db.put('test/b', {})
db.put('test/ccc', null)
db.put('test/dd', 'test')
db.put('test', 'asdf')

db.put('/test/bb', '')
db.put('/test/d', undefined)

db.put('/test', 'm3h')
/******************************************************************************
  USAGE API
******************************************************************************/
// OPTIONAL
// var opts           = { old: true, transform: function (x) { return x } }
// var logger         = function (x) { console.log(x) }
// REQUIRED
// var query1         = { 'key/name' : 'default/value' }
// var query2         = 'key/name' // when there is no default value
// var db             = db.tracker(db, logger)
// var trackerstream$ = db.track(query1)
// var trackerstream$ = db.track(query1, opts)
// var trackerstream$ = db.track(query2)
// var trackerstream$ = db.track(query2, opts)
// trackerstream$.on("loaded", function () {})
// trackerstream$.untrack()
///////////////////////////////////////////////////////////////////////////////
setTimeout(function () {
  var TSfile$ = db.track('test')
  var TSdirectory$ = db.track('test/')
  logging(null, '=== tracking ===')
  show('TSfile',TSfile$)
  show('TSdirectory',TSdirectory$)
  function show (name, TS$) {
    TS$.on('data', function () {
      logging(null, name + ' : ' + JSON.stringify(arguments, null, 2))
    })
    TS$.on('end', function () {
      logging(null, name + ' stream ends')
    })
  }
  var id = setInterval(filldb, 300)
  function filldb () {
    var l = Math.floor(Math.random() * 2) + 1
    var key = '/test/'
    for (var i = 0; i < l; i++) {
      key += String.fromCharCode(Math.random() * 26 + 97)
    }
    db.put([key, 'blabla'], { n: Math.floor(Math.random() * 100) })
    db.put(['/test', 'bla'], { n: Math.floor(Math.random() * 100) })
  }
  setTimeout(function () {
    clearTimeout(id)
    //db.close()
    logging(null, '========')
  }, 3000)
  setTimeout(function () {
    //db.open()
    // setInterval(filldb, 300)
    db.createReadStream().on('data', function (data) {
      logging(null, data)
    })
  }, 4000)
}, 1000)
/********************************************************************
  LOGGING
********************************************************************/
var konsole
function logging (err, data) {
  if (!konsole) { konsole = getKonsole() }
  var x = document.createElement('div')
  x.className = 'line'
  x.style.fontFamily = 'Arial'
  x.style.paddingTop = '10px'
  if (typeof data === 'string') {
    x.innerHTML = data
  } else {
    x.innerHTML = JSON.stringify(data)
  }
  konsole.appendChild(x)
}
function getKonsole () {
  var style = document.createElement('style')
  style.innerHTML = [
    ".konsole{",
      "background-color: black;",
      "padding: 5px;",
      "box-sizing: border-box;",
      "color: white;",
      "position: absolute;",
      "width:100%;",
      "height:95vh;",
      "display: flex;",
      "overflow: scroll;",
      "flex-direction:column;",
    "}"
  ].join('')
  document.body.appendChild(style)
  var konsole = document.createElement('div')
  konsole.className = 'konsole'
  document.body.appendChild(konsole)
  return konsole
}
/******************************************************************************
  level-tracker
******************************************************************************/
function tracker (db, logapi) {
  if (!db) {
    throw new Error('no db instance given')
  }
  else if (db.track) {
    if (db.track !== track) {
      throw new Error('conflict: db.track already in use by another extension')
    }
  }
  else {
    db['track'] = track
    logger = (typeof logapi) === 'function' ? logapi : logger
    db.on('put', put)
    db.on('del', del)
    db.on('batch', batch)
    db.on('closed', function () {
      logging(null, 'db closed')
    })
    db.on('open', function () {
      logging(null, 'open db')
    })
    /*
      // @XXX: If there was a way to keep a "db.createReadStream"
      // open to stream also future db updates, it would be better
      // to have a db.createReadStream(...) that listens for the range,
      // instead of .on(...) listeners
      db.emit('put', key, value) // emitted when a new value is 'put'
      db.emit('del', key) // emitted when a value is deleted
      db.emit('batch', ary) // emitted when a batch operation has executed
      db.emit('ready') // emitted when the database has opened ('open' is synonym)
      db.emit('closed') // emitted when the database has closed
      db.emit('opening') // emitted when the database is opening
      db.emit('closing') // emitted when the database is closing
      db.emit('error', err) // only if no callback was passed
      @TODO do when all listeners are removed
      db.removeListener("put", put)
      db.removeListener("del", del)
      db.removeListener("batch", batch)
      @TODO: add when first listener is attached
    */
  }
  return db
}
/******************************************************************************
  HELPER - default logger noop
******************************************************************************/
function logger (opts) { /* console.log('API LOGGING: ', opts) */ }
/******************************************************************************
  HELPER - track query
******************************************************************************/
function track (query, opts) {
  var db     = this
  var config = validate(db, query, opts)
  logger({ query: query, _config: config })
  var gte = config.gte
  var lt  = config.lt
  var old = config.old
  var fn  = config.transform
  function check (key) { return (gte<=key) && (key<lt) }
  var trackerstream$ = createTrackerStream(check, fn)
  if (old) { streamOldData(db, trackerstream$, config) }
  return trackerstream$
}
/******************************************************************************
  HELPER - Validate & Sanitize parameter
******************************************************************************/
function validate (db, query, opts) {
  query = validateAndSanitizeQuery(query)
  maybePopulateDefault(db, query)
  return validateAndSanitizeOptions(query.key, opts)
}
/******************************************************************************
  HELPER - Validate & Sanitize query
******************************************************************************/
function validateAndSanitizeQuery (query) {
  if (!query) {
    throw new Error('no "query" given')
  }
  else if (typeof query === 'string') {
    var key = query
    query = {}
    query[key] = null
  }
  var counter = 0
  for (var x in query) { var key = x, val = query[key]; counter++ }
  if (counter !== 1) { throw new Error('"query": string OR { key: default }')}
  var hasKey     = ((typeof key) === 'string')
  if (!hasKey) { throw new Error('no "query" or "query.key" string given') }
  return { key: key, defaultValue: val }
}
/******************************************************************************
  HELPER - maybePopulateDefault
******************************************************************************/
function maybePopulateDefault (db, key, val ) {
  if ((typeof val) !== undefined) { db.get(key, populate) }
  function populate (doesntExist) { if (doesntExist) { db.put(key, val) } }
}
/******************************************************************************
  HELPER - Validate & Sanitize options
******************************************************************************/
function validateAndSanitizeOptions (key, opts) {
  opts              = defined(opts, {})
  var config        = {}
  var fn            = opts.transform
  config.transform  = (typeof fn)==='function'?fn:function id (x) { return x }
  config.old        = defined(opts.old, true)
  // if `old===true`, all entries that match
  // the range between `gte` and `lte` and are already in the database
  // will be pushed into the `trackerstream` once.
  // Afterwards, only live updates will be streamed.
  var key           = key[0] === '/' ? key : '/'+ key
  var isDirectory   = key[key.length-1] === '/'
  var suffix        = isDirectory ? '!' : ''
  // '!' - first printable char (pos 33)in the ASCII range
  var terminator    = isDirectory ? '\uffff\uffff' : '!'
  // ASCII range is all that matters when it comes to comparing keys
  // Increase gte/lt to stop at the end of the range you care about
  //
  // 'ab' comes after 'aa' because of the second byte
  // => gte:'aa', lt:'ab'
  // which would work great, if you want to exclude 'ab' in your keys
  // 'z' - last char of the alphabet
  // => gte:'aa', lt:'aaz'
  // which would work great unless you have e.g. '2' in your keys
  // '~' - last "printable" char (pos 126) of the lower ASCII range
  // => gte:'aa', lt:'aa~'
  // which would work great unless you have '~' in your keys
  // '\xff' - end char (pos 255) of the full ASCII range
  // => gte:'aa', lt:'aa\xff'
  // which would work great unless you have non-ascii data in your keys
  // '\uffff' - last unicode charcter
  // => gte:'aa', lt:'aa\uffff'
  // which would work great unless '\uffff' is used as a seperator already
  // => gte:'aa', lt:'aa\uffff\uffff'
  config.gte        = key + suffix
  config.lt         = key + terminator
  return config
}
/******************************************************************************
  HELPER - createTrackerStream
******************************************************************************/
function createTrackerStream (checkScope, interpretation) {
  var ts$ = readable({ read: function () {}, objectMode: true })
  ts$._checkScope      = checkScope
  ts$._interpretation  = interpretation
  function untrack () {
    var i = TRACKERSTREAMS.indexOf(ts$)
    if(!~i) false
    TRACKERSTREAMS.splice(i, 1)
    return true
  } // @FIXME find O(1) instead of O(n) solution to manage trackerstreams
  ts$.on('end'  , untrack)
  ts$.on('close', untrack)
  ts$.untrack   = untrack
  TRACKERSTREAMS.push(ts$)
  return ts$
}
/******************************************************************************
  HELPER - streamOldData
******************************************************************************/
function streamOldData (db, ts$, opts) {
  var reader = db.createReadStream(opts)
  var writer = writable({ objectMode: true })
  writer._write = function (chunk, encoding, next) {
    chunk.type = "put" // because a db readStream lacks the "type" attribute
    chunk = ts$._interpretation(chunk)
    if (chunk !== undefined) { ts$.push(chunk) }
    next()
  }
  writer.on('end', function loaded() {
    trackerstream$.emit("loaded")
    writer.emit("finish")
    reader.unpipe(writer)
  })
  reader.pipe(writer)
}
/******************************************************************************
  HELPER - Manage Trackerstreams
******************************************************************************/
function batch (arr)      { arr.forEach(each) }
function put   (key, val) { each({ type: 'put', key: key, value: val }) }
function del   (key, val) { each({ type: 'del', key: key, value: val }) }
function each  (item)     { TRACKERSTREAMS.forEach(function publish (ts$) {
  var scope = ts$._checkScope(String(item.key))
  if (scope) { ts$.push(ts$._interpretation(item)) }
})}
