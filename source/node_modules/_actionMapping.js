// EXAMPLE
// @NOTE: different visual components can trigger auth.js
// => auth.js sets 'esova-credentials' or produces a
//    status message (e.g. no valid token/promocode/etc...)
// => some listeners might want to respond to those

// @IDEA IMPLEMENTATION
// be careful to use setTimeout so an ACTION RESPONSE
// can still see the ACTION TRIGGER in the "stack trace"
// !!!! => THIS IS VITAL !!!!

// @IDEA
// a certain STATUS can affect multiple components
// => 1. an overlay showing/revealing itself
// => 2. existing component changing appearance (e.g. blurring)

// @IDEA: [A] and [B] below are old thinking and might need reconsideration
// @TODO [A] MY CURRENT THOUGHTS
// EVENT / STATUS / ACTION proxy
// all actions/status/event from all components are intercepted here
// and routed to the interested components
//
// @IDEA [B] MY VISION THOUGHTS
// once components specify "requirements" or support for "component queries" exists, they can also communicate directly with other components - but until then, hard coding might break stuff + users dont necessarily know what other component need to be present in the DOM for one component in order to work

/*
  @IDEA: maybe allow combining actions into new actions
  @IDEA: map { type: '???', ... } to [{ type:'put/del/...', ...}]

*/
function ACTION_signIn (promocode) { // BACKEND COMMUNICATION
  /******************************/
  // @IDEA (ACTION COMMUNICATION)
  // ACTIONS === SERVICE?
  // instead of "ACTION_signIn" do "db.put('ACTION:signIn')" or similar
  // maybe define "response channel too", then later
  //
  // @TODO: how to define a "response channel" for exclusive communication?
  //     => is that even desirable? ...
  // 1. can every module define it's own response channel for the same action?
  //     => YES, see below - it just needs mapping
  //    PRO: not broadcasting, so less traffic
  //    CON: might introduce need for additional requests, but could be served
  //         from a cache ...
  //    DISCUSSION WITH MYSELF:
  //    => so one module asks for "advancement of state"
  //    => why would rest just be informed if they ask?
  //    ==> that might result in unnecessary POLLING needs
  //    => so if it's kind of "global state", everyone should be informed
  //    => if it's private state it should stay "module internal"
  //    => if it's group communication .. is that wanted?
  //
  // 2. if a response channel is defined, then only the "asker" gets the
  //      response or another module if by coincidence they defined the
  //      same response channel
  //   => modules serve - the behavior is defined in the mapping
  //   => in theory a "discrimination" can be done
  //      by putting logic in the mapping logic
  //
  // 3. how to prevent others from being informed too?
  //    => ?????? Choose private communication by ...
  //
  /******************************/
  // SUBJECT:
  // 1. EXTERNAL WORLD (allowed by USER) or
  // 2. USER
  // => trigger changes
  // => The whole UI (composed from many components) needs to act on it
  //  - a single component might receive the EXTERNAL WORLD UPDATE initially
  //  - a single component might receive the USER UPDATE initially
  //  => They might contain logic based on which they decide whether its
  //     a relevant or irrelevant update,
  //     so a USER can design their filter bubble
  //       => if deemed irrelevant, initial component might not act
  //       => if deemed relevant, they should publish internally
  //         -> so all components subscribed will learn about the update
  //
  // USE CASE:
  // 1. the non-visual "auth module" might be used
  //    by several visual components.
  // How should they communicate?
      // db.put('AUTH', error, function (error) { // in header.js
      //   // @HACK currently have a "global" listener listens to this
      // })
  /******************************/
  // PATTERN
  // 2. "SEND MESSAGE"
  //    db.put('action:actionName', 'PAYLOAD', function (error) {
  //      // could not execute action
  //    })
  //    PUBLISH "component namespaced" OUTGOING COMMUNICATION CHANNEL
  //    => read only to externals, read/write to putting component
  //    => db.put or db.del or db.batch
  // 1. "LISTEN TO RESPONSE" CHANNEL db.on(...)
  //    db.on('action:actionName:responseType')
  //    PUBLISH "component namespaced" INCOMING COMMUNICATION CHANNEL
  //    => db.on
  //    => read only to listener, read/write to emitter
  //
  // MODULE A
  //    db.put('action:231', 'payload')
  // SUPPORTED RESPONSE TYPES
  //    db.on('action:231:status:success', function (payload) { })
  //    db.on('action:231:status:error', function (payload) { })
  //
  // MODULE B
  //    db.put('action:335', 'payload')
  // SUPPORTED RESPONSE TYPES
  //    db.on('action:335:status:success', function (payload) { })
  //    db.on('action:335:status:error', function (payload) { })
  //
  // @TODO: without defining a "response channel" (for different statuses)
  // => will there be "default response channels"?
  // => which statuses are supported for response channels?
  // => discoverable API?
  //
  // ACTION HANDLER
  // db.on('action:447', function (payload) {
  //     // SUPPORTED RESPONSE TYPES
  //     if (isX) db.put('action:447:status:XYZ')
  //     else db.put('action:447:status:BBB')
  // })
  //
  // ACTION MAPPING
  // map action:231 & action:335 => action:447
  // map action:447:status:XYZ => action:335:success
  // map action:447:status:BBB => action:231:success
  /******************************/
  // @IDEA: FUTURE
  // MAPPING
  // => once a maybe central "ACTION MODULE" handled the request
  //   -> it will do a "db.put('RESPONSE_CHANNEL')" to inform the requester
  // ROUTING
  // => or a ACTION LOAD BALANCER will distribute the request
  // BROKERAGE
  // => or an ACTION BROKER will get what's best
  //
  // THINK: maybe similar to rust's ownership idea?
  // => maybe it's possible to pass-by-value vs. pass-by-reference
  // @XXX: think about a components standard response channel
  // @XXX: think about generic name creation for a components actions

  // @TODO: USE CASES (for testing)
  //
  // @NOTE "action injection" is having the right db.on(...) listeners
  //
  // @NOTE if action is purely internal,
  // => put an internal db.on(...) listener in same module as the db.put(..)
  //  => maybe that would be a default that could be overwritten by
  //     => an external one if needed...
  //  => EVES DROPPING basically
  //
  // @NOTE if an action is meant to stay purely internal, make an internal
  //  => function call and handle with a callback
  // @TODO: how to choose a specific "action handler"?
  // @IDEA: Choose a specific action handler: require('action')
  //
  // @TODO: pattern obersavtion with manual experiments:
  // db.on('put', function (key, value) {
  //   try {value=JSON.parse(value)} catch (e) {value=defined(value,{})}
  //
  //   if (key === 'patternA') {
  //     var meaningfulname = value // or value.propOfInterest
  //     // ...
  //   } else if (....) {
  //     // ...
  //   }
  // })
}
